<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ç‹¼äººæ€å¯¹å±€è§‚æˆ˜é¢æ¿</title>
    <link rel="icon" href="data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3e%3ccircle cx='16' cy='16' r='14' fill='none' stroke='%231f6feb' stroke-width='2'/%3e%3ctext x='16' y='21' text-anchor='middle' font-family='Segoe UI' font-size='14' fill='%231f6feb'%3eW%3c/text%3e%3c/svg%3e">
<style>
        body {
            font-family: "Segoe UI", Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: #f4f6fa;
            color: #1f2933;
        }
        header {
            background: #1f6feb;
            color: #fff;
            padding: 16px 24px;
        }
        header h1 {
            margin: 0 0 8px;
            font-size: 20px;
        }
        main {
            padding: 24px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px 16px;
            align-items: center;
            margin-bottom: 16px;
        }
        .toolbar .group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .toolbar .status {
            margin-left: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 200px;
            text-align: right;
        }
        .app-header {
            background: #1f6feb;
            color: #fff;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }
        .app-header .brand { display: flex; align-items: center; gap: 12px; }
        .app-header .logo {
            width: 28px; height: 28px; border-radius: 6px; background:#0e4fb7; display:flex; align-items:center; justify-content:center; font-weight:700;
        }
        .app-header h1 { margin: 0; font-size: 18px; }
        .app-header p { margin: 2px 0 0; font-size: 12px; opacity: .9; }
        .header-actions { display:flex; align-items:center; gap: 8px; }
        .header-actions input[type="search"] { padding: 8px 12px; border-radius: 6px; border: 1px solid #90b4f7; min-width: 240px; }
        .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }

        .layout-2col { display: grid; grid-template-columns: 300px 1fr; gap: 16px; }
        .sidebar.sticky { position: sticky; top: 12px; height: fit-content; align-self: start; }

        /* ç´§å‡‘å¯†åº¦æ¨¡å¼ */
        .dense body, body.dense {
            --dense-scale: .92;
        }
        body.dense * { font-size: calc(1rem * var(--dense-scale)); }
        body.dense .event { padding: 10px; gap: 8px; }
        body.dense .round-header { padding: 8px 12px; }
        label {
            font-weight: 600;
        }
        select, button {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #cbd5e1;
            font-size: 14px;
        }
        button {
            background: #1f6feb;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        button:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }
        .match-meta {
            background: #fff;
            padding: 16px;
            margin-bottom: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(15, 23, 42, 0.08);
        }
        .list {
            list-style: none;
            padding: 0;
            margin: 8px 0 0;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .list li {
            padding: 4px 8px;
            border-radius: 999px;
            background: #e2e8f0;
            font-size: 13px;
        }
        .round {
            background: #fff;
            margin-bottom: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(15, 23, 42, 0.05);
        }
        .round-header {
            padding: 12px 16px;
            border-bottom: 1px solid #e2e8f0;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
        }
        .round-count {
            margin-left: auto;
            font-size: 12px;
            color: #64748b;
        }
        .round-toggle {
            background: transparent;
            border: none;
            color: #1f6feb;
            cursor: pointer;
            font-size: 12px;
            padding: 4px 6px;
            border-radius: 6px;
        }
        .round-toggle:hover,
        .round-toggle:focus-visible {
            background: rgba(31, 110, 235, 0.12);
            outline: none;
        }
        .round.collapsed .round-toggle { color: #2563eb; }
        .round-content { display: grid; }
        .round.collapsed .round-content { display: none; }
        .round--hidden { display: none !important; }
        .empty {
            text-align: center;
            color: #64748b;
            padding: 48px 16px;
            background: #fff;
            border-radius: 8px;
        }

        .event {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 16px;
            border-bottom: 1px solid #f1f5f9;
        }
        .event:last-child {
            border-bottom: none;
        }
        .event--hidden-by-search {
            display: none !important;
        }
        .event-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            background: #1f6feb;
            flex-shrink: 0;
        }
        .event-body {
            flex: 1;
            display: grid;
            gap: 8px;
        }
        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            flex-wrap: wrap;
            gap: 8px;
        }
        .event-speaker {
            font-weight: 600;
        }
        .event-meta {
            font-size: 12px;
            color: #64748b;
        }
        .event-content {
            background: #f8fafc;
            border-radius: 12px;
            padding: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        .event-extra {
            margin-top: 12px;
            background: #f1f5f9;
            border-radius: 10px;
            padding: 10px 12px;
            font-size: 12px;
            color: #475569;
        }
        .event-extra__title {
            margin: 0 0 6px;
            font-weight: 600;
            color: #1f2933;
        }
        .event-meta-list {
            display: grid;
            grid-template-columns: minmax(72px, 110px) 1fr;
            gap: 4px 12px;
            margin: 0;
        }
        .event-meta-list dt {
            font-weight: 600;
        }
        .event-meta-list dd {
            margin: 0;
            word-break: break-all;
        }
        .event-meta-list pre {
            margin: 0;
            padding: 6px 8px;
            border-radius: 6px;
            background: #e2e8f0;
            font-family: "JetBrains Mono", "Fira Code", Consolas, monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .event-raw {
            margin-top: 12px;
            font-size: 12px;
        }
        .event-raw summary {
            cursor: pointer;
            color: #2563eb;
            outline: none;
        }
        .event-raw summary::-webkit-details-marker { display: none; }
        .event-raw pre {
            margin: 8px 0 0;
            padding: 8px 10px;
            border-radius: 8px;
            background: #0f172a0d;
            font-family: "JetBrains Mono", "Fira Code", Consolas, monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 320px;
            overflow: auto;
        }
        .event--system {
            background: #ecfdf5;
            border-left: 4px solid #34d399;
        }
        .event--system .event-avatar {
            background: #34d399;
        }
        .event--system .event-content {
            background: transparent;
            color: #047857;
            padding-left: 0;
        }
        .empty {
            box-shadow: 0 2px 4px rgba(15, 23, 42, 0.05);
            border-radius: 12px;
        }
        /* æ–°å¢å¸ƒå±€ä¸ç»„ä»¶æ ·å¼ */
        .layout {
            display: grid;
            grid-template-columns: minmax(260px, 320px) 1fr;
            gap: 24px;
            align-items: start;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 16px;
            position: sticky;
            top: 24px;
        }
        .timeline {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        @media (max-width: 920px) {
            .layout { grid-template-columns: 1fr; }
            .sidebar { position: static; }
        }
        .panel {
            background: #fff;
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 2px 6px rgba(15, 23, 42, 0.08);
        }
        .status-line { font-size: 13px; color: #64748b; }
        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: flex-end;
        }
        .filter-group { display: grid; gap: 6px; min-width: 160px; }
        @media (max-width: 980px) {
            .toolbar { flex-direction: column; align-items: stretch; }
            .toolbar .status { margin-left: 0; text-align: left; }
        }
        .event-tags { display: flex; flex-wrap: wrap; gap: 6px; }
        .event-tag { font-size: 12px; padding: 4px 8px; border-radius: 999px; background: #e0f2fe; color: #0369a1; }
        .button-secondary { background: transparent; color: #1f6feb; border: 1px solid #90b4f7; }
        .button-secondary:hover { background: rgba(31,110,235,0.08); }
        .error-card { background:#fff7ed; border-radius:12px; border:1px solid #fed7aa; color:#9a3412; padding:24px; display:grid; gap:12px; text-align:center; }
        /* æ–°å¢åŠ¨ç”»ï¼šæœ€æ–°è½®æ¬¡é—ªçƒ */
        @keyframes roundFlash {
            0% { box-shadow: 0 0 0 0 rgba(34,197,94,0.45); outline: 2px solid rgba(34,197,94,0.6); }
            100% { box-shadow: 0 0 0 14px rgba(34,197,94,0); outline-color: transparent; }
        }
        .round--flash { animation: roundFlash 1.2s ease-out; }
        /* åŠ¨æ•ˆå˜é‡ä¸åŸºç¡€ Keyframes */
        :root {
            --anim-fast: 120ms;
            --anim-base: 240ms;
            --anim-slow: 600ms;
            --ease-out: cubic-bezier(0.22, 1, 0.36, 1);
        }
        @keyframes kf-enter { from { opacity: 0; transform: translateY(12px);} to { opacity: 1; transform: none; } }
        @keyframes kf-pulse { 0%{transform: scale(1);} 50%{transform: scale(1.04);} 100%{transform: scale(1);} }
        @keyframes kf-float { 0%{ transform: translateY(0);} 50%{ transform: translateY(-4px);} 100%{ transform: translateY(0);} }
        @keyframes kf-sweep { 0%{ background-position: -150% 0;} 100%{ background-position: 150% 0;} }
        @keyframes kf-wobble { 0%{ transform: rotate(0deg);} 25%{ transform: rotate(-1.5deg);} 75%{ transform: rotate(1.5deg);} 100%{ transform: rotate(0deg);} }
        @media (prefers-reduced-motion: reduce) {
            * { animation-duration: 1ms !important; animation-iteration-count: 1 !important; transition-duration: 1ms !important; }
        }
        /* äº‹ä»¶å…¥åœºè½»åŠ¨æ•ˆ */
        .event { animation: kf-enter var(--anim-base) var(--ease-out); }
        /* é˜¶æ®µæ¨ªå¹… */
        .banner { position: sticky; top: 0; z-index: 30; display: none; margin: 0 0 12px; padding: 10px 14px; border-radius: 12px; color: #0b1320; box-shadow: 0 2px 8px rgba(15,23,42,.12); font-weight: 700; letter-spacing: .5px; }
        .banner--show { display: block; animation: kf-enter var(--anim-slow) var(--ease-out); }
        .banner--day { background: linear-gradient(90deg,#fde68a, #f8fafc); }
        .banner--night { background: linear-gradient(90deg,#111827, #0b1320); color: #e5e7eb; }
        /* è§’è‰²åŠ¨ç”»å ä½ç±»ï¼Œä½œç”¨äº .event-avatar */
        .anim-wolf-sweep { position: relative; overflow: hidden; }
        .anim-wolf-sweep::after { content: ""; position: absolute; inset: 0; background: linear-gradient(110deg, rgba(255,255,255,0) 0%, rgba(255,255,255,.35) 50%, rgba(255,255,255,0) 100%); background-size: 200% 100%; animation: kf-sweep var(--anim-fast) ease-out 1; pointer-events: none; }
        .anim-seer-orbit { position: relative; }
        .anim-seer-orbit::after { content: ""; position: absolute; width: 6px; height: 6px; border-radius: 50%; background: #f59e0b; top: -3px; left: 50%; transform-origin: -12px 21px; animation: kf-float 600ms ease-in-out 1, orbit 2s linear 1; }
        @keyframes orbit { from{ transform: rotate(0deg);} to{ transform: rotate(360deg);} }
        .anim-witch-float { animation: kf-float 800ms ease-in-out 1; }
        .anim-hunter-wobble { animation: kf-wobble 120ms ease-out 1; }
        .anim-guardian-shield-in { box-shadow: 0 0 0 2px rgba(59,130,246,.3) inset; animation: kf-pulse 300ms var(--ease-out) 1; }
        .anim-pulse { animation: kf-pulse 1200ms var(--ease-out) 1; }
        /* æš—è‰²ä¸»é¢˜åŸºç¡€é€‚é… */
        @media (prefers-color-scheme: dark) {
            body { background-color: #0b1320; color: #e5e7eb; }
            header { background: #0f1f3a; color: #e5e7eb; }
            .panel, .match-meta, .round, .empty { background: #0f172a; box-shadow: 0 2px 6px rgba(0,0,0,.4); }
            .round-header { border-bottom-color: #1f2937; }
            .round-count { color: #94a3b8; }
            .event-extra { background: #0b1626; color: #cfd9f1; }
            .event-extra__title { color: #e2e8f0; }
            .event-meta-list pre { background: #192642; color: #e2e8f0; }
            .event-raw summary { color: #90b4f7; }
            .event-raw pre { background: #16213a; color: #e2e8f0; }
            .list li { background: #1f2937; color: #e2e8f0; }
            .event { border-bottom: 1px solid #142033; }
            .event-content { background: #0b1626; }
            .event--system { background: #06251a; border-left-color: #34d399; }
            .event--system .event-content { color: #a7f3d0; }
            .status-line { color: #94a3b8; }
            .button-secondary { color: #90b4f7; border-color: #375bd2; }
            .button-secondary:hover { background: rgba(31,110,235,0.12); }
            .banner--day { background: linear-gradient(90deg,#7c6f3a, #0f172a); color: #fde68a; }
            .banner--night { background: linear-gradient(90deg,#0b1320, #020617); color: #e2e8f0; }
        }
        /* ç³»ç»Ÿäº‹ä»¶æ ·å¼å¢å¼º */
        .event--system { position: relative; overflow: hidden; }
        .event--system.sys-exile { border-left-color: #f59e0b; }
        .event--system.sys-nightkill { border-left-color: #ef4444; }
        .event--system.sys-victory { border-left-color: #22c55e; }
        .event--system.sys-nightkill::before { content: ""; position: absolute; inset: 0; background: linear-gradient(120deg, rgba(239,68,68,0) 0%, rgba(239,68,68,.18) 50%, rgba(239,68,68,0) 100%); background-size: 200% 100%; animation: kf-sweep var(--anim-fast) ease-out 1; pointer-events: none; }
        .event--system.sys-exile::before { content: ""; position: absolute; inset: 0; background: linear-gradient(120deg, rgba(245,158,11,0) 0%, rgba(245,158,11,.14) 50%, rgba(245,158,11,0) 100%); background-size: 200% 100%; animation: kf-sweep var(--anim-fast) ease-out 1; pointer-events: none; }
        .event--system.sys-victory { box-shadow: 0 0 0 1px rgba(34,197,94,.18) inset; }
        /* ç³»ç»Ÿäº‹ä»¶å›¾æ ‡ä¸å¸ƒå±€ */
        .event-icon { display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; margin-right: 8px; font-size: 14px; line-height: 1; opacity: .9; }
        .event--system .event-header { align-items: center; }
        .event--system.sys-exile .event-icon { color: #f59e0b; }
        .event--system.sys-nightkill .event-icon { color: #ef4444; }
        .event--system.sys-victory .event-icon { color: #22c55e; }
        
    </style>
</head>
<body>
    <header class="app-header">
        <div class="brand">
            <div class="logo" aria-hidden="true">W</div>
            <div class="titles">
                <h1>ç‹¼äººæ€å¯¹å±€è§‚æˆ˜é¢æ¿</h1>
                <p>å®æ—¶æŸ¥çœ‹å„ä½ç©å®¶åœ¨è®¨è®ºé˜¶æ®µçš„å‘è¨€ä»¥åŠç³»ç»Ÿæç¤ºã€‚</p>
            </div>
        </div>
        <div class="header-actions">
            <label class="sr-only" for="textSearch">æœç´¢å‘è¨€</label>
            <input id="textSearch" type="search" placeholder="æœç´¢å†…å®¹/ç©å®¶/é¢‘é“...">
            <button id="toggleDensityBtn" class="button-secondary" type="button" aria-pressed="false">ç´§å‡‘æ¨¡å¼</button>
        </div>
    </header>
    <main>
        <div id="stageBanner" class="banner" aria-live="polite" hidden></div>
        <section class="toolbar panel">
            <div class="group">
                <label for="matchSelect">å¯¹å±€</label>
                <select id="matchSelect"></select>
                <a href="/graph.html" class="button-secondary" role="button">æŠ•ç¥¨/æŒ‡æ§å…³ç³»å›¾</a>
            </div>
            <div class="group">
                <button id="refreshBtn" type="button">ç«‹å³åˆ·æ–°</button>
                <button id="toggleAutoRefreshBtn" type="button">æš‚åœè‡ªåŠ¨åˆ·æ–°</button>
                <label for="refreshIntervalSelect">åˆ·æ–°é¢‘ç‡</label>
                <select id="refreshIntervalSelect">
                    <option value="3000">3 ç§’</option>
                    <option value="5000" selected>5 ç§’</option>
                    <option value="10000">10 ç§’</option>
                </select>
            </div>
            <div class="status">
                <span class="status-line" id="statusText">åŠ è½½ä¸­...</span>
                <span class="status-line" id="lastUpdatedText">ä¸Šæ¬¡åŒæ­¥ï¼š--</span>
            </div>
        </section>
        <div class="layout layout-2col">
            <aside class="sidebar sticky">

                <section class="match-meta panel" id="matchMeta" hidden>
                    <div><strong>å½“å‰é˜¶æ®µï¼š</strong><span id="phaseText">-</span></div>
                    <div><strong>å½“å‰è½®æ¬¡ï¼š</strong><span id="roundText">-</span></div>
                    <div>
                        <strong>å­˜æ´»ç©å®¶ï¼š</strong>
                        <ul class="list" id="aliveList"></ul>
                    </div>
                    <div>
                        <strong>å‡ºå±€ç©å®¶ï¼š</strong>
                        <ul class="list" id="deadList"></ul>
                    </div>
                </section>

            </aside>

            <section class="timeline">
                <section class="filters panel" id="filtersPanel" hidden>
                    <div class="filter-group">
                        <label for="speakerFilter">å‘è¨€ç±»å‹</label>
                        <select id="speakerFilter">
                            <option value="all">å…¨éƒ¨</option>
                            <option value="player">ç©å®¶å‘è¨€</option>
                            <option value="system">ç³»ç»Ÿæç¤º</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="playerFilter">ç©å®¶ç­›é€‰</label>
                        <select id="playerFilter" disabled>
                            <option value="all">å…¨éƒ¨ç©å®¶</option>
                        </select>
                    </div>
                    <button class="button-secondary" id="resetFiltersBtn" type="button">é‡ç½®ç­›é€‰</button>
                    <button class="button-secondary" id="jumpToLatestBtn" type="button">è·³è‡³æœ€æ–°</button>
                </section>

                <section id="logContainer">
                    <div class="empty" id="emptyState">æš‚æ— å‘è¨€è®°å½•</div>
                </section>
            </section>
        </div>
    </main>

    <script>
        const matchSelect = document.getElementById('matchSelect');
        const refreshBtn = document.getElementById('refreshBtn');
        const toggleAutoRefreshBtn = document.getElementById('toggleAutoRefreshBtn');
        const refreshIntervalSelect = document.getElementById('refreshIntervalSelect');
        const statusText = document.getElementById('statusText');
        const lastUpdatedText = document.getElementById('lastUpdatedText');
        const matchMeta = document.getElementById('matchMeta');
        const phaseText = document.getElementById('phaseText');
        const roundText = document.getElementById('roundText');
        const aliveList = document.getElementById('aliveList');
        const deadList = document.getElementById('deadList');
        const filtersPanel = document.getElementById('filtersPanel');
        const speakerFilter = document.getElementById('speakerFilter');
        const playerFilter = document.getElementById('playerFilter');
        const resetFiltersBtn = document.getElementById('resetFiltersBtn');
        const logContainer = document.getElementById('logContainer');
        const textSearch = document.getElementById('textSearch');
        const toggleDensityBtn = document.getElementById('toggleDensityBtn');
        const emptyState = document.getElementById('emptyState');
        const jumpToLatestBtn = document.getElementById('jumpToLatestBtn');
        const stageBanner = document.getElementById('stageBanner');
        
        // AIé…ç½®ç›¸å…³å…ƒç´ 
        const aiConfigPanel = document.getElementById('aiConfigPanel');
        const toggleAiConfigBtn = document.getElementById('toggleAiConfigBtn');
        const aiConfigContent = document.getElementById('aiConfigContent');
        const aiProvider = document.getElementById('aiProvider');
        const apiKey = document.getElementById('apiKey');
        const baseUrl = document.getElementById('baseUrl');
        const modelName = document.getElementById('modelName');
        const loadAiConfigBtn = document.getElementById('loadAiConfigBtn');
        const saveAiConfigBtn = document.getElementById('saveAiConfigBtn');
        const toggleApiKeyBtn = document.getElementById('toggleApiKeyBtn');
        const resetBaseUrlBtn = document.getElementById('resetBaseUrlBtn');
        const providerHelp = document.getElementById('providerHelp');
        const baseUrlHelp = document.getElementById('baseUrlHelp');
        const configStatus = document.getElementById('configStatus');

        let currentMatch = null;
        let autoRefreshTimer = null;
        let autoRefreshEnabled = true;
        let autoRefreshInterval = Number(refreshIntervalSelect.value) || 5000;
        let lastUpdatedAt = null;
        let latestMatchPayload = null;
        let lastEventTimestamp = null;
        let lastPhase = null;

        const filters = {
            speaker: speakerFilter.value,
            player: playerFilter.value,
        };

        const STORAGE_KEY = 'webui_prefs_v1';

        function setStatus(message, type = 'info') {
            statusText.textContent = message;
            statusText.style.color = type === 'error' ? '#dc2626' : '#64748b';
        }

        function clearChildren(node) {
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
        }

        function updateLastUpdatedText() {
            const prefix = autoRefreshEnabled ? 'ä¸Šæ¬¡åŒæ­¥' : 'è‡ªåŠ¨åˆ·æ–°å·²æš‚åœ Â· ä¸Šæ¬¡åŒæ­¥';
            const timeText = lastUpdatedAt ? new Date(lastUpdatedAt).toLocaleTimeString() : '--';
            lastUpdatedText.textContent = `${prefix}ï¼š${timeText}`;
        }

        function touchLastUpdated() {
            lastUpdatedAt = Date.now();
            updateLastUpdatedText();
        }

        function updateAutoRefreshControls() {
            toggleAutoRefreshBtn.textContent = autoRefreshEnabled ? 'æš‚åœè‡ªåŠ¨åˆ·æ–°' : 'æ¢å¤è‡ªåŠ¨åˆ·æ–°';
            toggleAutoRefreshBtn.setAttribute('aria-pressed', String(!autoRefreshEnabled));
            refreshIntervalSelect.disabled = !autoRefreshEnabled;
        }

        function loadPrefs() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return;
                const p = JSON.parse(raw);
                if (p.refreshInterval && Number.isFinite(+p.refreshInterval)) {
                    refreshIntervalSelect.value = String(p.refreshInterval);
                    autoRefreshInterval = +p.refreshInterval;
                }
                if (typeof p.autoRefreshEnabled === 'boolean') {
                    autoRefreshEnabled = p.autoRefreshEnabled;
                }
                if (p.speaker && ['all','player','system'].includes(p.speaker)) {
                    speakerFilter.value = p.speaker;
                    filters.speaker = p.speaker;
                }
                if (p.player) {
                    filters.player = p.player;
                }
            } catch {}
        }

        function savePrefs() {
            try {
                const p = {
                    refreshInterval: autoRefreshInterval,
                    autoRefreshEnabled,
                    speaker: filters.speaker,
                    player: filters.player,
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(p));
            } catch {}
        }

        function renderEmptyState(message) {
            clearChildren(logContainer);
            emptyState.textContent = message;
            emptyState.style.display = 'block';
            logContainer.appendChild(emptyState);
        }

        function showErrorState(message) {
            clearChildren(logContainer);
            filtersPanel.hidden = true;
            const card = document.createElement('div');
            card.className = 'error-card';
            const title = document.createElement('p');
            title.textContent = message;
            const retry = document.createElement('button');
            retry.type = 'button';
            retry.className = 'button-secondary';
            retry.textContent = 'é‡è¯•';
            retry.addEventListener('click', () => {
                if (currentMatch) {
                    loadMatch(currentMatch);
                } else {
                    loadMatches();
                }
            });
            card.append(title, retry);
            logContainer.appendChild(card);
        }

        function showStageBanner(phase) {
            if (!stageBanner) return;
            const text = typeof phase === 'string' ? phase : String(phase || 'é˜¶æ®µå˜æ›´');
            const lower = text.toLowerCase();
            const isNight = lower.includes('night') || text.includes('å¤œ') || lower.includes('dark') || lower.includes('evening');
            stageBanner.textContent = isNight ? `å¤œæ™šå¼€å§‹` : `å¤©äº®äº†`;
            stageBanner.classList.remove('banner--night','banner--day','banner--show');
            stageBanner.classList.add(isNight ? 'banner--night' : 'banner--day');
            stageBanner.hidden = false;
            requestAnimationFrame(() => {
                stageBanner.classList.add('banner--show');
                setTimeout(() => {
                    stageBanner.classList.remove('banner--show');
                    stageBanner.hidden = true;
                }, 900);
            });
        }

        async function loadMatches() {
            setStatus('åŠ è½½å¯¹å±€åˆ—è¡¨...');
            try {
                const response = await fetch('/api/matches');
                if (!response.ok) throw new Error('åˆ—è¡¨æ¥å£é”™è¯¯');
                const data = await response.json();
                populateMatches(data.matches || []);
            } catch (err) {
                console.error(err);
                setStatus('è·å–å¯¹å±€åˆ—è¡¨å¤±è´¥', 'error');
                if (!latestMatchPayload) {
                    showErrorState('æš‚æ—¶æ— æ³•è·å–å¯¹å±€ï¼Œè¯·ç¨åé‡è¯•');
                }
            }
        }

        function populateMatches(matches) {
            clearChildren(matchSelect);
            if (!matches.length) {
                const option = document.createElement('option');
                option.textContent = 'æš‚æ— è¿›è¡Œä¸­çš„å¯¹å±€';
                option.value = '';
                matchSelect.appendChild(option);
                currentMatch = null;
                latestMatchPayload = null;
                renderMatch(null);
                setStatus('ç­‰å¾…æ–°å¯¹å±€...');
                return;
            }

            matches.forEach((item, index) => {
                const option = document.createElement('option');
                option.value = item.match_id;
                option.textContent = `#${index + 1} / ${item.match_id.slice(0, 8)}`;
                matchSelect.appendChild(option);
            });

            const nextMatch = currentMatch && matches.some(m => m.match_id === currentMatch)
                ? currentMatch
                : matches[0].match_id;
            matchSelect.value = nextMatch;
            currentMatch = nextMatch;
            setStatus('å¯¹å±€åˆ—è¡¨æ›´æ–°å®Œæˆ');
            loadMatch(nextMatch);
        }

        async function loadMatch(matchId) {
            if (!matchId) {
                renderMatch(null);
                return;
            }
            setStatus('æ‹‰å–å‘è¨€è®°å½•...');
            try {
                const response = await fetch(`/api/matches/${matchId}/speech-log`);
                if (!response.ok) throw new Error('æ—¥å¿—æ¥å£é”™è¯¯');
                const data = await response.json();
                if (data && data.phase) {
                    const p = String(data.phase).toLowerCase();
                    if (lastPhase === null) {
                        lastPhase = data.phase;
                    } else if (data.phase !== lastPhase) {
                        showStageBanner(data.phase);
                        lastPhase = data.phase;
                    }
                }
                const newLastTs = getLastEventTimestamp(Array.isArray(data.speech_log) ? data.speech_log : []);
                latestMatchPayload = data;
                renderMatch(data);
                if (lastEventTimestamp === null || (newLastTs !== null && newLastTs > lastEventTimestamp)) {
                    flashLatestRound();
                    lastEventTimestamp = newLastTs;
                }
                touchLastUpdated();
                setStatus('æœ€æ–°æ•°æ®å·²åŒæ­¥');
            } catch (err) {
                console.error(err);
                setStatus('è·å–å‘è¨€è®°å½•å¤±è´¥', 'error');
                if (!latestMatchPayload) {
                    showErrorState('è·å–å‘è¨€è®°å½•å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            }
        }

        function renderMatch(match, options = {}) {
            const { fromCache = false } = options;
            if (!match) {
                if (!fromCache) {
                    latestMatchPayload = null;
                }
                matchMeta.hidden = true;
                filtersPanel.hidden = true;
                renderEmptyState('æš‚æ— å‘è¨€è®°å½•');
                return;
            }

            matchMeta.hidden = false;
            phaseText.textContent = match.phase || '-';
            roundText.textContent = match.round || '-';

            renderPlayerList(aliveList, match.alive_players || []);
            renderPlayerList(deadList, match.dead_players || []);

            if (!fromCache) {
                populatePlayerFilter(match);
            }

            const rawEvents = Array.isArray(match.speech_log) ? match.speech_log : [];
            const hasAnyEvents = rawEvents.length > 0;
            const filteredEvents = applyFilters(rawEvents);
            const grouped = groupByRound(filteredEvents);

            clearChildren(logContainer);

            if (!hasAnyEvents) {
                filtersPanel.hidden = true;
                renderEmptyState('æš‚æ— å‘è¨€è®°å½•');
                return;
            }

            filtersPanel.hidden = false;

            if (!grouped.size) {
                renderEmptyState('ç­›é€‰æ¡ä»¶ä¸‹æš‚æ— è®°å½•');
                return;
            }
            emptyState.style.display = 'none';

            const rounds = Array.from(grouped.entries()).map(([roundKey, events]) => {
                const sortedEvents = [...events].sort((a, b) => {
                    const parsedA = a.timestamp ? Date.parse(a.timestamp) : 0;
                    const parsedB = b.timestamp ? Date.parse(b.timestamp) : 0;
                    const timeA = Number.isNaN(parsedA) ? 0 : parsedA;
                    const timeB = Number.isNaN(parsedB) ? 0 : parsedB;
                    return timeB - timeA;
                });
                return {
                    roundKey,
                    events: sortedEvents,
                    lastTimestamp: getLastEventTimestamp(sortedEvents)
                };
            });

            const roundWeight = (round) => {
                if (typeof round.lastTimestamp === 'number' && !Number.isNaN(round.lastTimestamp)) {
                    return round.lastTimestamp;
                }
                return parseRoundKey(round.roundKey);
            };

            rounds.sort((a, b) => {
                const weightDiff = roundWeight(b) - roundWeight(a);
                if (!Number.isNaN(weightDiff) && weightDiff !== 0) {
                    return weightDiff;
                }
                const roundDiff = parseRoundKey(b.roundKey) - parseRoundKey(a.roundKey);
                if (!Number.isNaN(roundDiff) && roundDiff !== 0) {
                    return roundDiff;
                }
                return 0;
            });

            rounds.forEach((round, index) => {
                const roundCard = document.createElement('article');
                roundCard.className = 'round';
                roundCard.dataset.round = round.roundKey;

                const header = document.createElement('div');
                header.className = 'round-header';

                const title = document.createElement('span');
                title.className = 'round-title';
                title.textContent = `ç¬¬ ${round.roundKey} è½®`;

                const count = document.createElement('span');
                count.className = 'round-count';
                count.dataset.total = String(round.events.length);
                count.textContent = `${round.events.length} æ¡è®°å½•`;

                const toggleBtn = document.createElement('button');
                toggleBtn.type = 'button';
                toggleBtn.className = 'round-toggle';

                header.append(title, count, toggleBtn);
                roundCard.appendChild(header);

                const content = document.createElement('div');
                content.className = 'round-content';
                const contentIdBase = String(round.roundKey).replace(/[^a-zA-Z0-9_-]/g, '') || 'round';
                const contentId = `round-content-${index}-${contentIdBase}`;
                content.id = contentId;
                toggleBtn.setAttribute('aria-controls', contentId);
                round.events.forEach(event => {
                    content.appendChild(createEventElement(event));
                });
                roundCard.appendChild(content);

                const collapsed = index !== 0;
                if (collapsed) {
                    roundCard.classList.add('collapsed');
                    toggleBtn.textContent = 'å±•å¼€';
                    toggleBtn.setAttribute('aria-expanded', 'false');
                } else {
                    toggleBtn.textContent = 'æ”¶èµ·';
                    toggleBtn.setAttribute('aria-expanded', 'true');
                }

                const toggle = () => {
                    const isCollapsed = roundCard.classList.toggle('collapsed');
                    toggleBtn.textContent = isCollapsed ? 'å±•å¼€' : 'æ”¶èµ·';
                    toggleBtn.setAttribute('aria-expanded', String(!isCollapsed));
                };
                toggleBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    toggle();
                });
                header.addEventListener('click', (event) => {
                    if (event.target.closest('.round-toggle')) { return; }
                    toggle();
                });

                logContainer.appendChild(roundCard);
            });
        }

        function renderPlayerList(target, players) {
            clearChildren(target);
            if (!players.length) {
                const placeholder = document.createElement('li');
                placeholder.textContent = '-';
                target.appendChild(placeholder);
                return;
            }
            players.forEach(name => {
                const li = document.createElement('li');
                li.textContent = name;
                target.appendChild(li);
            });
        }

        function populatePlayerFilter(match) {
            const previous = filters.player;
            const names = new Set();
            (match.alive_players || []).forEach(name => { if (name) names.add(name); });
            (match.dead_players || []).forEach(name => { if (name) names.add(name); });
            (match.speech_log || []).forEach(event => {
                const label = event.display_name || event.player_id;
                if (label) names.add(label);
            });
            const sortedNames = Array.from(names).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN', { sensitivity: 'base' }));

            clearChildren(playerFilter);
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.textContent = 'å…¨éƒ¨ç©å®¶';
            playerFilter.appendChild(allOption);

            sortedNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                playerFilter.appendChild(option);
            });

            if (sortedNames.includes(previous)) {
                playerFilter.value = previous;
                filters.player = previous;
            } else if (filters.player !== 'all' && sortedNames.includes(filters.player)) {
                playerFilter.value = filters.player;
            } else {
                playerFilter.value = 'all';
                filters.player = 'all';
            }

            playerFilter.disabled = !sortedNames.length;
            savePrefs();
        }

        function applyFilters(events) {
            return events.filter(event => {
                const speakerType = event.speaker_type || 'player';
                if (filters.speaker === 'system' && speakerType !== 'system') { return false; }
                if (filters.speaker === 'player' && speakerType === 'system') { return false; }
                if (filters.player !== 'all') {
                    const label = event.display_name || event.player_id;
                    if (label !== filters.player) { return false; }
                }
                return true;
            });
        }

        function normalizeRole(raw) {
            if (!raw) return '';
            const s = String(raw).trim().toLowerCase();
            const map = {
                'ç‹¼äºº': 'werewolf', 'ç‹¼': 'werewolf', 'werewolf': 'werewolf',
                'é¢„è¨€å®¶': 'seer', 'seer': 'seer', 'å åœå¸ˆ': 'seer',
                'å¥³å·«': 'witch', 'witch': 'witch',
                'çŒäºº': 'hunter', 'hunter': 'hunter',
                'å®ˆå«': 'guardian', 'å®ˆæŠ¤': 'guardian', 'guardian': 'guardian',
                'æ‘æ°‘': 'villager', 'å¹³æ°‘': 'villager', 'villager': 'villager',
                'ä¸˜æ¯”ç‰¹': 'cupid', 'cupid': 'cupid'
            };
            return map[s] || s;
        }

        function groupByRound(events) {
            const sorted = [...events].sort((a, b) => {
                const parsedA = a.timestamp ? Date.parse(a.timestamp) : 0;
                const parsedB = b.timestamp ? Date.parse(b.timestamp) : 0;
                const timeA = Number.isNaN(parsedA) ? 0 : parsedA;
                const timeB = Number.isNaN(parsedB) ? 0 : parsedB;
                return timeA - timeB;
            });
            const map = new Map();
            sorted.forEach(event => {
                const round = event.round ?? 'æœªçŸ¥';
                if (!map.has(round)) { map.set(round, []); }
                map.get(round).push(event);
            });
            return map;
        }

        function parseRoundKey(key) {
            if (key == null) return Number.NEGATIVE_INFINITY;
            const cleaned = String(key).match(/-?\d+(?:\.\d+)?/);
            if (!cleaned) return Number.NEGATIVE_INFINITY;
            const num = Number(cleaned[0]);
            return Number.isFinite(num) ? num : Number.NEGATIVE_INFINITY;
        }

        function getLastEventTimestamp(events) {
            let last = null;
            for (const ev of events) {
                if (!ev.timestamp) continue;
                const t = Date.parse(ev.timestamp);
                if (!Number.isNaN(t)) {
                    if (last === null || t > last) last = t;
                }
            }
            return last;
        }

        function scrollToLatest() {
            const latestRound = document.querySelector('#logContainer .round:nth-of-type(1)');
            if (latestRound) {
                latestRound.scrollIntoView({ behavior: 'smooth', block: 'start' });
                latestRound.classList.add('round--flash');
                setTimeout(() => latestRound.classList.remove('round--flash'), 1200);
            }
        }

        function flashLatestRound() {
            const latestRound = document.querySelector('#logContainer .round:nth-of-type(1)');
            if (latestRound) {
                latestRound.classList.add('round--flash');
                setTimeout(() => latestRound.classList.remove('round--flash'), 1200);
            }
        }

        function formatSpeakerLabel(event, speakerType) {
            if (speakerType === 'system') {
                return event.display_name || 'ä¸Šå¸';
            }
            const name = event.display_name || event.player_id || 'æœªçŸ¥ç©å®¶';
            return event.role ? `${name} (${event.role})` : name;
        }

        function formatMeta(event) {
            if (!event.timestamp) { return '-'; }
            const parsed = Date.parse(event.timestamp);
            if (Number.isNaN(parsed)) { return '-'; }
            return new Date(parsed).toLocaleTimeString();
        }

        function formatDateTime(value) {
            if (!value) { return null; }
            const parsed = Date.parse(value);
            if (Number.isNaN(parsed)) { return value; }
            const date = new Date(parsed);
            return `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
        }

        function createDefinitionList(pairs) {
            const dl = document.createElement('dl');
            dl.className = 'event-meta-list';
            let appended = false;
            pairs.forEach(([label, value]) => {
                if (value === undefined || value === null || value === '') {
                    return;
                }
                appendDefinitionItem(dl, label, value);
                appended = true;
            });
            return appended ? dl : null;
        }

        function appendDefinitionItem(dl, label, value) {
            const dt = document.createElement('dt');
            dt.textContent = label;
            const dd = document.createElement('dd');
            if (typeof value === 'object') {
                const pre = document.createElement('pre');
                pre.textContent = JSON.stringify(value, null, 2);
                dd.appendChild(pre);
            } else {
                dd.textContent = String(value);
            }
            dl.append(dt, dd);
        }

        function getAvatarText(event, speakerType) {
            if (speakerType === 'system') {
                return 'ç¥';
            }
            const name = event.display_name || event.player_id || '?';
            return name.charAt(0).toUpperCase();
        }

        function createEventElement(event) {
            const speakerType = event.speaker_type || 'player';
            const wrapper = document.createElement('div');
            wrapper.className = 'event';
            wrapper.dataset.speakerType = speakerType;
            wrapper.dataset.channel = event.channel || 'speech';
            if (speakerType === 'system') {
                wrapper.classList.add('event--system');
                const text = ((event.content || '') + ' ' + (event.action || '') + ' ' + (event.type || '')).toString();
                const isExile = /æ”¾é€|æ”¾ç¥¨|æŠ•ç¥¨|ç¥¨å‹/.test(text);
                const isNightKill = /å¤œæ€|å‡»æ€|è¢«åˆ€|åˆ€æ­»|æ­»äº¡/.test(text);
                const isVictory = /èƒœåˆ©|è·èƒœ|å¤±è´¥|æ¸¸æˆç»“æŸ|ç»“æŸ/.test(text);
                if (isExile) wrapper.classList.add('sys-exile');
                if (isNightKill) wrapper.classList.add('sys-nightkill');
                if (isVictory) wrapper.classList.add('sys-victory');
            }

            const avatar = document.createElement('div');
            avatar.className = 'event-avatar';
            avatar.textContent = getAvatarText(event, speakerType);
            avatar.setAttribute('aria-hidden', 'true');

            const body = document.createElement('div');
            body.className = 'event-body';

            const header = document.createElement('div');
            header.className = 'event-header';
            const speaker = document.createElement('span');
            speaker.className = 'event-speaker';
            speaker.textContent = formatSpeakerLabel(event, speakerType);
            const meta = document.createElement('span');
            meta.className = 'event-meta';
            meta.textContent = formatMeta(event);

            // ç³»ç»Ÿäº‹ä»¶ï¼šåœ¨æ ‡é¢˜å‰æ³¨å…¥å›¾æ ‡
            if (speakerType === 'system') {
                const icon = document.createElement('span');
                icon.className = 'event-icon';
                const text = wrapper.classList.contains('sys-nightkill') ? 'ğŸ—¡ï¸' : (wrapper.classList.contains('sys-exile') ? 'ğŸ—³ï¸' : (wrapper.classList.contains('sys-victory') ? 'ğŸ†' : 'â„¹ï¸'));
                icon.textContent = text;
                icon.setAttribute('aria-hidden', 'true');
                header.prepend(icon);
            }

            header.append(speaker, meta);
            body.appendChild(header);

            // è§’è‰²å ä½åŠ¨ç”»ï¼šåœ¨å¤´åƒä¸Šè§¦å‘ä¸€æ¬¡æ€§çŸ­åŠ¨ç”»
            if (speakerType === 'player') {
                const role = normalizeRole(event.role);
                const animClassMap = {
                    werewolf: 'anim-wolf-sweep',
                    seer: 'anim-seer-orbit',
                    witch: 'anim-witch-float',
                    hunter: 'anim-hunter-wobble',
                    guardian: 'anim-guardian-shield-in',
                    villager: 'anim-pulse',
                    cupid: 'anim-pulse',
                };
                const cls = animClassMap[role];
                if (cls) {
                    avatar.classList.add(cls);
                    setTimeout(() => avatar.classList.remove(cls), 1500);
                }
            }

            const tags = [];
            if (event.phase) { tags.push(event.phase); }
            const channel = event.channel || 'speech';
            if (channel !== 'speech') { tags.push(`#${channel}`); }
            if (tags.length) {
                const tagList = document.createElement('div');
                tagList.className = 'event-tags';
                tags.forEach(text => {
                    const tag = document.createElement('span');
                    tag.className = 'event-tag';
                    tag.textContent = text;
                    tagList.appendChild(tag);
                });
                body.appendChild(tagList);
            }

            const content = document.createElement('div');
            content.className = 'event-content';
            content.textContent = event.content || '';

            body.appendChild(content);

            const infoPairs = [
                ['æ—¶é—´', formatDateTime(event.timestamp)],
                ['é¢‘é“', channel],
                ['é˜¶æ®µ', event.phase],
                ['è½®æ¬¡', event.round],
                ['ç©å®¶ID', event.player_id],
                ['è§’è‰²', event.role],
                ['æ˜¾ç¤ºåç§°', event.display_name],
            ];
            const infoList = createDefinitionList(infoPairs);
            if (infoList) {
                const infoSection = document.createElement('div');
                infoSection.className = 'event-extra';
                const infoTitle = document.createElement('div');
                infoTitle.className = 'event-extra__title';
                infoTitle.textContent = 'äº‹ä»¶ä¿¡æ¯';
                infoSection.append(infoTitle, infoList);
                body.appendChild(infoSection);
            }

            if (event.metadata && typeof event.metadata === 'object' && Object.keys(event.metadata).length) {
                const metaList = createDefinitionList(Object.entries(event.metadata));
                if (metaList) {
                    const metaSection = document.createElement('div');
                    metaSection.className = 'event-extra';
                    const metaTitle = document.createElement('div');
                    metaTitle.className = 'event-extra__title';
                    metaTitle.textContent = 'é™„åŠ æ•°æ®';
                    metaSection.append(metaTitle, metaList);
                    body.appendChild(metaSection);
                }
            }

            const rawDetails = document.createElement('details');
            rawDetails.className = 'event-raw';
            const summary = document.createElement('summary');
            summary.textContent = 'æŸ¥çœ‹åŸå§‹äº‹ä»¶æ•°æ®';
            const pre = document.createElement('pre');
            pre.textContent = JSON.stringify(event, null, 2);
            rawDetails.append(summary, pre);
            body.appendChild(rawDetails);

            wrapper.append(avatar, body);

            return wrapper;
        }

        matchSelect.addEventListener('change', event => {
            currentMatch = event.target.value;
            loadMatch(currentMatch);
        });

        refreshBtn.addEventListener('click', () => {
            if (currentMatch) {
                loadMatch(currentMatch);
            } else {
                loadMatches();
            }
        });

        function rerenderFromCache() {
            if (latestMatchPayload) {
                renderMatch(latestMatchPayload, { fromCache: true });
            }
        }

        toggleAutoRefreshBtn.addEventListener('click', () => {
            autoRefreshEnabled = !autoRefreshEnabled;
            updateAutoRefreshControls();
            updateLastUpdatedText();
            savePrefs();
            scheduleAutoRefresh();
        });

        refreshIntervalSelect.addEventListener('change', event => {
            const next = Number(event.target.value);
            if (!Number.isFinite(next) || next <= 0) { return; }
            autoRefreshInterval = next;
            savePrefs();
            scheduleAutoRefresh();
        });

        speakerFilter.addEventListener('change', event => {
            filters.speaker = event.target.value;
            savePrefs();
            rerenderFromCache();
        });

        playerFilter.addEventListener('change', event => {
            filters.player = event.target.value;
            savePrefs();
            rerenderFromCache();
        });

        resetFiltersBtn.addEventListener('click', () => {
            filters.speaker = 'all';
            filters.player = 'all';
            speakerFilter.value = 'all';
            playerFilter.value = 'all';
            savePrefs();
            rerenderFromCache();
        });

        jumpToLatestBtn.addEventListener('click', () => {
            scrollToLatest();
        });

        function scheduleAutoRefresh() {
            if (autoRefreshTimer) {
                clearInterval(autoRefreshTimer);
                autoRefreshTimer = null;
            }
            if (!autoRefreshEnabled) { return; }
            autoRefreshTimer = setInterval(() => {
                if (currentMatch) {
                    loadMatch(currentMatch);
                } else {
                    loadMatches();
                }
            }, autoRefreshInterval);
        }

        // AIé…ç½®ç›¸å…³å‡½æ•°
        function showConfigStatus(message, type = 'success') {
            configStatus.textContent = message;
            configStatus.className = `config-status ${type}`;
            setTimeout(() => {
                configStatus.className = 'config-status';
            }, 3000);
        }

        function updateProviderUI() {
            const provider = aiProvider.value;
            if (provider === 'openai') {
                apiKey.disabled = false;
                apiKey.placeholder = 'è¾“å…¥APIå¯†é’¥';
                baseUrl.placeholder = 'https://api.openai.com/v1';
                if (baseUrl.value === 'http://localhost:11434/v1') {
                    baseUrl.value = '';
                }
                if (providerHelp) providerHelp.textContent = 'OpenAI éœ€æä¾› API å¯†é’¥ï¼›å¯ç•™ç©º Base URL ä½¿ç”¨é»˜è®¤åŸŸåã€‚';
                if (baseUrlHelp) baseUrlHelp.textContent = 'OpenAI å¯ç•™ç©ºä½¿ç”¨é»˜è®¤åŸŸåï¼ˆhttps://api.openai.com/v1ï¼‰';
            } else if (provider === 'ollama') {
                apiKey.value = '';
                apiKey.disabled = true;
                apiKey.placeholder = 'æœ¬åœ°æ¨¡å‹æ— éœ€å¯†é’¥';
                if (!baseUrl.value.trim()) {
                    baseUrl.value = 'http://localhost:11434/v1';
                }
                baseUrl.placeholder = 'http://localhost:11434/v1';
                if (providerHelp) providerHelp.textContent = 'Ollama ä¸ºæœ¬åœ°æ¨¡å‹ï¼Œé€šå¸¸æ— éœ€å¯†é’¥ï¼›è¯·ç¡®è®¤ Base URL';
                if (baseUrlHelp) baseUrlHelp.textContent = 'æ¨èä½¿ç”¨ http://localhost:11434/v1ï¼Œæˆ–æ ¹æ®å®é™…æœåŠ¡è°ƒæ•´';
            } else {
                apiKey.disabled = false;
                apiKey.placeholder = 'æ ¹æ®ä¾›åº”å•†è¦æ±‚å¡«å†™';
                baseUrl.placeholder = 'ä¾‹å¦‚ï¼šhttps://your-endpoint/v1';
                if (providerHelp) providerHelp.textContent = 'è‡ªå®šä¹‰ä¾›åº”å•†ï¼šæ ¹æ®å®é™…è¦æ±‚å¡«å†™å¯†é’¥ä¸ Base URL';
                if (baseUrlHelp) baseUrlHelp.textContent = 'è¯·å¡«å†™å…¼å®¹ OpenAI API çš„åŸºç¡€ URL';
            }
        }

        function toggleAiConfigPanel() {
            const isHidden = aiConfigContent.hidden;
            aiConfigContent.hidden = !isHidden;
            toggleAiConfigBtn.textContent = isHidden ? 'æ”¶èµ·' : 'å±•å¼€';
            
            // é¦–æ¬¡å±•å¼€æ—¶åŠ è½½é…ç½®
            if (isHidden) {
                loadAiConfig();
            }
        }

        async function loadAiConfig() {
            try {
                const response = await fetch('/api/ai-config');
                if (!response.ok) throw new Error('è·å–é…ç½®å¤±è´¥');
                const config = await response.json();
                
                // å¡«å……è¡¨å•
                aiProvider.value = config.AI_PROVIDER || 'openai';
                apiKey.value = config.OPENAI_API_KEY && !config.OPENAI_API_KEY.includes('*') ? config.OPENAI_API_KEY : '';
                baseUrl.value = config.OPENAI_BASE_URL || '';
                modelName.value = config.OPENAI_MODEL_NAME || config.AI_MODEL_NAME || '';
                updateProviderUI();
                
                showConfigStatus('é…ç½®å·²åŠ è½½', 'success');
            } catch (error) {
                console.error('åŠ è½½AIé…ç½®å¤±è´¥:', error);
                showConfigStatus('åŠ è½½é…ç½®å¤±è´¥: ' + error.message, 'error');
            }
        }

        async function saveAiConfig() {
            try {
                const provider = aiProvider.value;
                const key = (apiKey.value || '').trim();
                const url = (baseUrl.value || '').trim();

                if (provider === 'openai' && !key) {
                    showConfigStatus('OpenAI æ¨¡å¼éœ€è¦å¡«å†™ API å¯†é’¥', 'error');
                    return;
                }
                if (provider !== 'openai' && !url) {
                    showConfigStatus('æœ¬åœ°/è‡ªå®šä¹‰æä¾›å•†éœ€è¦è®¾ç½® Base URL', 'error');
                    return;
                }

                saveAiConfigBtn.disabled = true;

                const config = {
                    AI_PROVIDER: provider,
                    OPENAI_API_KEY: key,
                    OPENAI_BASE_URL: url,
                    OPENAI_MODEL_NAME: modelName.value
                };
                
                const response = await fetch('/api/ai-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(config)
                });
                
                if (!response.ok) throw new Error('ä¿å­˜é…ç½®å¤±è´¥');
                const result = await response.json();
                
                if (result.success) {
                    showConfigStatus('é…ç½®å·²ä¿å­˜ï¼Œé‡å¯æ¸¸æˆåç”Ÿæ•ˆ', 'success');
                } else {
                    throw new Error(result.error || 'æœªçŸ¥é”™è¯¯');
                }
            } catch (error) {
                console.error('ä¿å­˜AIé…ç½®å¤±è´¥:', error);
                showConfigStatus('ä¿å­˜é…ç½®å¤±è´¥: ' + error.message, 'error');
            } finally {
                saveAiConfigBtn.disabled = false;
            }
        }

        // AIé…ç½®äº‹ä»¶ç›‘å¬å™¨
        toggleAiConfigBtn.addEventListener('click', toggleAiConfigPanel);
        loadAiConfigBtn.addEventListener('click', loadAiConfig);
        saveAiConfigBtn.addEventListener('click', saveAiConfig);
        aiProvider.addEventListener('change', updateProviderUI);
        if (toggleApiKeyBtn) {
            toggleApiKeyBtn.addEventListener('click', () => {
                const isPassword = apiKey.type === 'password';
                apiKey.type = isPassword ? 'text' : 'password';
                toggleApiKeyBtn.textContent = isPassword ? 'éšè—' : 'æ˜¾ç¤º';
            });
        }
        if (resetBaseUrlBtn) {
            resetBaseUrlBtn.addEventListener('click', () => {
                const provider = aiProvider.value;
                if (provider === 'openai') {
                    baseUrl.value = '';
                } else if (provider === 'ollama') {
                    baseUrl.value = 'http://localhost:11434/v1';
                } else {
                    baseUrl.value = '';
                }
                showConfigStatus('å·²é‡ç½®ä¸ºæ¨èçš„ Base URL', 'info');
            });
        }

        // åˆå§‹åŒ–AIé…ç½®é¢æ¿
        aiConfigPanel.hidden = false;
        updateProviderUI();

        // æ–‡å­—ç­›é€‰ä¸å¯†åº¦æ¨¡å¼ï¼šåˆå§‹åŒ–ä¸æ¸²æŸ“åè¿‡æ»¤
        function filterTimelineByText() {
            try {
                const q = (document.getElementById('textSearch')?.value || '').trim().toLowerCase();
                const container = document.getElementById('logContainer');
                if (!container) return;
                const events = container.querySelectorAll('.event');
                const rounds = container.querySelectorAll('.round');

                if (!q) {
                    events.forEach(ev => {
                        ev.style.display = '';
                        ev.classList.remove('event--hidden-by-search');
                    });
                    rounds.forEach(card => {
                        card.classList.remove('round--hidden');
                        card.style.display = '';
                        const countEl = card.querySelector('.round-count');
                        if (countEl) {
                            const total = Number(countEl.dataset.total) || card.querySelectorAll('.event').length;
                            countEl.textContent = `${total} æ¡è®°å½•`;
                        }
                    });
                    emptyState.style.display = 'none';
                    emptyState.textContent = 'æš‚æ— å‘è¨€è®°å½•';
                    return;
                }

                events.forEach(ev => {
                    const text = ev.innerText || ev.textContent || '';
                    const matched = text.toLowerCase().includes(q);
                    ev.style.display = matched ? '' : 'none';
                    ev.classList.toggle('event--hidden-by-search', !matched);
                });

                rounds.forEach(card => {
                    const allEvents = Array.from(card.querySelectorAll('.event'));
                    const visibleEvents = allEvents.filter(ev => ev.style.display !== 'none');
                    const hasVisible = visibleEvents.length > 0;
                    card.classList.toggle('round--hidden', !hasVisible);
                    card.style.display = hasVisible ? '' : 'none';

                    const countEl = card.querySelector('.round-count');
                    if (countEl) {
                        const total = Number(countEl.dataset.total) || allEvents.length;
                        if (!hasVisible) {
                            countEl.textContent = `0 / ${total} æ¡è®°å½•`;
                        } else if (visibleEvents.length === total) {
                            countEl.textContent = `${total} æ¡è®°å½•`;
                        } else {
                            countEl.textContent = `${visibleEvents.length} / ${total} æ¡è®°å½•`;
                        }
                    }
                });

                const anyVisibleRound = Array.from(rounds).some(card => card.style.display !== 'none');
                if (!anyVisibleRound) {
                    emptyState.textContent = 'æ²¡æœ‰ç¬¦åˆæœç´¢æ¡ä»¶çš„è®°å½•';
                    emptyState.style.display = 'block';
                    if (!emptyState.parentElement) {
                        logContainer.appendChild(emptyState);
                    }
                } else {
                    emptyState.style.display = 'none';
                }
            } catch {}
        }

        const textSearchEl = document.getElementById('textSearch');
        if (textSearchEl) {
            textSearchEl.addEventListener('input', () => {
                try { localStorage.setItem('spectator:textSearch', textSearchEl.value); } catch {}
                filterTimelineByText();
            });
            // æ¢å¤å†å²æœç´¢è¯
            try {
                const prev = localStorage.getItem('spectator:textSearch');
                if (prev) { textSearchEl.value = prev; }
            } catch {}
        }

        const toggleDensityBtnEl = document.getElementById('toggleDensityBtn');
        if (toggleDensityBtnEl) {
            // æ¢å¤å¯†åº¦
            try {
                const dense = localStorage.getItem('spectator:dense') === '1';
                document.body.classList.toggle('dense', dense);
                toggleDensityBtnEl.setAttribute('aria-pressed', String(dense));
            } catch {}
            toggleDensityBtnEl.addEventListener('click', () => {
                const on = !document.body.classList.contains('dense');
                document.body.classList.toggle('dense', on);
                toggleDensityBtnEl.setAttribute('aria-pressed', String(on));
                try { localStorage.setItem('spectator:dense', on ? '1' : '0'); } catch {}
            });
        }

        // å½“æ—¶é—´çº¿DOMå˜åŒ–åï¼Œè‡ªåŠ¨åº”ç”¨æ–‡æœ¬è¿‡æ»¤
        const lc = document.getElementById('logContainer');
        if (lc && 'MutationObserver' in window) {
            const mo = new MutationObserver(() => { filterTimelineByText(); });
            mo.observe(lc, { childList: true });
        }

        loadPrefs();
        updateAutoRefreshControls();
        updateLastUpdatedText();
        loadMatches().then(() => { scheduleAutoRefresh(); filterTimelineByText(); });
    </script>
</body>
</html>
